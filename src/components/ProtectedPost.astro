---
import type { EncryptedPostPayload } from "@/utils/protectedPostCrypto";

interface Props {
  payload: EncryptedPostPayload;
  postId: string;
  passwordHint?: string;
}

const { payload, postId, passwordHint } = Astro.props;
const storageKey = `post-password:${postId}`;
---

<div data-protected-post data-storage-key={storageKey} data-pagefind-ignore>
  <section
    data-role="unlock-panel"
    class="mt-8 rounded-xl border border-border/40 bg-card/60 p-5"
  >
    <h2 class="text-xl font-semibold text-accent">这是一篇受保护文章</h2>
    <p class="mt-2 text-sm text-skin-base/80">
      请输入文章密码后解锁正文内容。
    </p>

    {
      passwordHint && (
        <p class="mt-2 text-sm text-skin-base/70">
          密码提示：<span class="font-medium">{passwordHint}</span>
        </p>
      )
    }

    <form data-role="unlock-form" class="mt-4 flex flex-col gap-3 sm:flex-row">
      <input
        type="password"
        name="password"
        autocomplete="current-password"
        placeholder="输入文章密码"
        class="w-full rounded-md border border-border/60 bg-background px-3 py-2 text-sm outline-none ring-accent/40 focus:ring-2"
        required
      />
      <button
        type="submit"
        data-role="submit-btn"
        class="rounded-md bg-accent px-4 py-2 text-sm font-semibold text-skin-inverted transition hover:opacity-90"
      >
        解锁
      </button>
    </form>

    <label class="mt-2 inline-flex items-center gap-2 text-xs text-skin-base/70">
      <input
        type="checkbox"
        name="remember"
        data-role="remember"
        class="h-4 w-4 rounded border-border bg-background accent-accent"
        checked
      />
      记住密码（当前设备）
    </label>

    <p
      data-role="error"
      class="mt-3 hidden rounded-md border border-red-500/25 bg-red-500/10 px-3 py-2 text-sm text-red-400"
    >
      密码错误，请重试。
    </p>
  </section>

  <article
    data-role="decrypted-content"
    class="app-prose relative mx-auto mt-8 hidden max-w-app prose-pre:bg-(--shiki-light-bg) dark:prose-pre:bg-(--shiki-dark-bg)"
    data-pagefind-ignore
  ></article>

  <script
    type="application/json"
    data-role="payload"
    set:html={JSON.stringify(payload)}
  ></script>

  <script is:inline>
    (() => {
      const currentScript = document.currentScript;
      const container = currentScript?.closest("[data-protected-post]");

      if (!container) {
        console.warn("Protected post container not found");
        return;
      }

      const root = container.querySelector('[data-role="unlock-panel"]');
      const form = container.querySelector('[data-role="unlock-form"]');
      const errorBox = container.querySelector('[data-role="error"]');
      const contentEl = container.querySelector('[data-role="decrypted-content"]');
      const payloadScript = container.querySelector('script[data-role="payload"]');
      const submitButton = container.querySelector('[data-role="submit-btn"]');
      const rememberInput = container.querySelector('[data-role="remember"]');
      const storageKey = container.getAttribute("data-storage-key") || "";
      const persistentStorageKey = `${storageKey}:persistent`;

      if (!root || !form || !errorBox || !contentEl || !payloadScript || !submitButton) {
        console.warn("Protected post elements are missing");
        return;
      }

      let payload;
      try {
        payload = JSON.parse(payloadScript.textContent || "{}");
      } catch {
        console.error("Invalid encrypted payload");
        return;
      }

      if (!window.crypto || !window.crypto.subtle) {
        errorBox.textContent = "当前浏览器不支持解密功能，请更换浏览器后重试。";
        errorBox.classList.remove("hidden");
        return;
      }

      const textEncoder = new TextEncoder();
      const textDecoder = new TextDecoder();
      const payloadVersion = payload?.iv || "";

      function base64ToBytes(base64) {
        const binary = atob(base64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return bytes;
      }

      function setSubmitting(isSubmitting) {
        submitButton.disabled = isSubmitting;
        submitButton.textContent = isSubmitting ? "解锁中..." : "解锁";
        submitButton.style.opacity = isSubmitting ? "0.7" : "1";
      }

      function readCachedPassword() {
        if (!storageKey) return null;

        const sessionPassword = sessionStorage.getItem(storageKey);
        if (sessionPassword) return sessionPassword;

        try {
          const persistentRaw = localStorage.getItem(persistentStorageKey);
          if (!persistentRaw) return null;
          const persistentData = JSON.parse(persistentRaw);
          if (
            persistentData &&
            persistentData.v === payloadVersion &&
            typeof persistentData.p === "string"
          ) {
            return persistentData.p;
          }
        } catch {
          localStorage.removeItem(persistentStorageKey);
        }

        return null;
      }

      function persistPassword(password) {
        if (!storageKey) return;
        sessionStorage.setItem(storageKey, password);

        if (rememberInput && rememberInput.checked) {
          localStorage.setItem(
            persistentStorageKey,
            JSON.stringify({ p: password, v: payloadVersion })
          );
        } else {
          localStorage.removeItem(persistentStorageKey);
        }
      }

      async function decryptHtml(password) {
        const keyMaterial = await crypto.subtle.importKey(
          "raw",
          textEncoder.encode(password),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );

        const key = await crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: base64ToBytes(payload.salt),
            iterations: payload.iterations,
            hash: "SHA-256",
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          false,
          ["decrypt"]
        );

        const decrypted = await crypto.subtle.decrypt(
          {
            name: "AES-GCM",
            iv: base64ToBytes(payload.iv),
          },
          key,
          base64ToBytes(payload.data)
        );

        return textDecoder.decode(decrypted);
      }

      async function unlock(password, showError = true) {
        setSubmitting(true);
        try {
          const html = await decryptHtml(password);
          contentEl.innerHTML = html;
          contentEl.classList.remove("hidden");
          root.classList.add("hidden");
          errorBox.classList.add("hidden");
          persistPassword(password);
          return true;
        } catch {
          if (showError) errorBox.classList.remove("hidden");
          return false;
        } finally {
          setSubmitting(false);
        }
      }

      form.addEventListener("submit", async event => {
        event.preventDefault();
        const data = new FormData(form);
        const password = String(data.get("password") || "");
        if (!password) return;
        await unlock(password, true);
      });

      const cachedPassword = readCachedPassword();
      if (cachedPassword) {
        unlock(cachedPassword, false);
      }
    })();
  </script>
</div>
